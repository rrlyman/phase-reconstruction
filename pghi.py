"""
Created on Jul 7, 2018

based upon

"A Non-iterative Method for (Re)Construction of Phase from STFT Magnitude"
Zdenek Prusa, Peter Balazs, Peter L. Sondergaard

@author: richard

to run:
    python PGHI_test.py
or
    python3 PGHI_test.py

"""

import numpy as np

import heapq

# import scipy.signal as signal
# import pghi_plot
from scipy import ndimage
from PGHI_base import PGHI_base


class PGHI(PGHI_base):
    """
    implements the Phase Gradient Heap Integration - PGHI algorithm
    """

    def __init__(
        self,
        **kwargs,
    ):
        super().__init__(**kwargs)

    def test_name(self, testName):
        super().test_name(testName, __name__)

    def dxdw(self, x):
        """return the derivative of x with respect to frequency"""
        xp = np.pad(x, 1, mode="edge")
        #         dw = (np.multiply(3,(xp[1:-1,:-2]) + np.multiply(2,xp[1:-1,1:-1]) + np.multiply(3,xp[1:-1,2:])) - np.multiply(6,(xp[1:-1,:-2] + xp[1:-1,1:-1] + xp[1:-1,2:])))/6
        dw = (xp[1:-1, 2:] - xp[1:-1, :-2]) / 2
        return dw

    def dxdt(self, x):
        """return the derivative of x with respect to time"""
        xp = np.pad(x, 1, mode="edge")
        #         dt = (np.multiply(3,(xp[:-2,1:-1]) + np.multiply(2,xp[1:-1,1:-1]) + np.multiply(3,xp[2:,1:-1])) - np.multiply(6,(xp[:-2,1:-1] + xp[1:-1,1:-1] + xp[2:,1:-1])))/6
        dt = (xp[2:, 1:-1] - xp[:-2, 1:-1]) / (2)

        return dt

    def magnitude_to_phase_estimate(self, magnitude):
        """estimate the phase frames from the magnitude
        parameter:
            magnitude
                numpy array containing the real absolute values of the
                magnitudes of each FFT frame.
                shape (n,m) where n is the frame step and
                m is the frequency step
        return
            estimated phase of each fft coefficient
                shape (n,m) where n is the frame step and
                m is the frequency step
                measure: radians per sample
        """

        N = magnitude.shape[0]
        M2, M, a_a = self.M2, self.M, self.a_a
        wbin = 2 * np.pi / self.M

        if self.plt.verbose:  # for debugging
            self.debug_count = 0
            try:
                original_phase = np.angle(self.corig_frames)
            except:
                original_phase = None
            self.q_errors = []

        logs = np.log(magnitude + 1e-50)

        # alternative
        #         fmul = self.lambdasqr*wbin/a

        fmul = self.gamma / (a_a * M)
        tgradplus = (2 * np.pi * a_a / M) * np.arange(M2)
        tgrad = self.dxdw(logs) / fmul + tgradplus

        fgradplus = np.pi
        fgrad = -fmul * self.dxdt(logs) + fgradplus

        dphaseNE = tgrad + fgrad
        dphaseSE = tgrad - fgrad

        phase = np.random.random_sample(magnitude.shape) * 2 * np.pi

        mask = magnitude > (self.tol * np.max(magnitude))
        active_padded = np.pad(mask, 1, mode="constant", constant_values=False)

        while np.any(active_padded):

            labeled, nr_objects = ndimage.label(active_padded[1 : N + 1, 1 : M2 + 1])
            self.logprint("number of islands = {}".format(nr_objects))
            startpoints = ndimage.maximum_position(
                magnitude * active_padded[1 : N + 1, 1 : M2 + 1],
                labeled,
                range(nr_objects + 1),
            )[1:]
            for startpoint in startpoints:
                hp = []
                n0, m0 = startpoint
                phase[n0, m0] = 0
                heapq.heappush(hp, (-magnitude[n0, m0], n0, m0))
                active_padded[n0 + 1, m0 + 1] = False
                if self.plt.verbose:
                    self.logprint(
                        "Processing Island: start point=[{},{}]".format(n0, m0)
                    )
                    #  For debugging purposes, align the original phase with the phase generated by this algorithm.
                    if original_phase is not None:
                        original_phase -= original_phase[n0, m0]
                while len(hp) > 0:
                    s = heapq.heappop(hp)
                    n, m = s[1], s[2]
                    if active_padded[(n + 1), m + 2]:  # North
                        active_padded[(n + 1), m + 2] = False  # padded is 1 indexed
                        phase[n, m + 1] = (
                            phase[n, m] + (fgrad[n, m] + fgrad[n, m + 1]) / 2
                        )
                        heapq.heappush(hp, (-magnitude[n, m + 1], n, m + 1))
                        if self.plt.verbose and self.debug_count <= 2000:
                            self.debugInfo(n, m + 1, n, m, phase, original_phase)

                    if active_padded[(n + 1), m]:  # South
                        active_padded[(n + 1), m] = False  # padded is 1 indexed
                        phase[n, m - 1] = (
                            phase[n, m] - (fgrad[n, m] + fgrad[n, m - 1]) / 2
                        )
                        heapq.heappush(hp, (-magnitude[n, m - 1], n, m - 1))
                        if self.plt.verbose and self.debug_count <= 2000:
                            self.debugInfo(n, m - 1, n, m, phase, original_phase)

                    if active_padded[(n + 2), m + 1]:  # East
                        active_padded[(n + 2), m + 1] = False  # padded is 1 indexed
                        phase[(n + 1), m] = (
                            phase[n, m]
                            + self.time_scale * (tgrad[n, m] + tgrad[(n + 1), m]) / 2
                        )
                        heapq.heappush(hp, (-magnitude[(n + 1), m], n + 1, m))
                        if self.plt.verbose and self.debug_count <= 2000:
                            self.debugInfo(n + 1, m, n, m, phase, original_phase)

                    if active_padded[n, m + 1]:  # West
                        active_padded[n, m + 1] = False  # padded is 1 indexed
                        phase[(n - 1), m] = (
                            phase[n, m]
                            - self.time_scale * (tgrad[n, m] + tgrad[(n - 1), m]) / 2
                        )
                        heapq.heappush(hp, (-magnitude[(n - 1), m], n - 1, m))
                        if self.plt.verbose and self.debug_count <= 2000:
                            self.debugInfo(n - 1, m, n, m, phase, original_phase)

        if self.plt.verbose:
            nprocessed = np.sum(np.where(mask, 1, 0))
            self.logprint(
                "magnitudes processed above threshold tolerance={}, magnitudes rejected below threshold tolerance={}".format(
                    nprocessed, magnitude.size - nprocessed
                )
            )
            self.plt.plot_3d(
                "magnitude", [magnitude], mask=mask, startpoints=startpoints
            )
            self.plt.plot_3d("fgrad", [fgrad], mask=mask, startpoints=startpoints)
            self.plt.plot_3d("tgrad", [tgrad], mask=mask, startpoints=startpoints)
            self.plt.plot_3d(
                "self.dxdw(logs) ",
                [self.dxdw(logs)],
                mask=mask,
                startpoints=startpoints,
            )
            self.plt.plot_3d(
                "self.dxdt(logs) ",
                [self.dxdt(logs)],
                mask=mask,
                startpoints=startpoints,
            )
            self.plt.plot_3d(
                "Phase estimated", [phase], mask=mask, startpoints=startpoints
            )
            if original_phase is not None:
                self.plt.plot_3d(
                    "Phase original",
                    [original_phase],
                    mask=mask,
                    startpoints=startpoints,
                )
                self.plt.plot_3d(
                    "Phase original, Phase estimated",
                    [(original_phase) % (2 * np.pi), (phase) % (2 * np.pi)],
                    mask=mask,
                    startpoints=startpoints,
                )
                self.plt.colorgram(
                    "Phase original minus Phase estimated",
                    np.abs((original_phase) % (2 * np.pi) - (phase) % (2 * np.pi)),
                    mask=mask,
                    startpoints=startpoints,
                )
                self.plt.quiver("phase errors", self.q_errors, startpoints=startpoints)
        return phase
